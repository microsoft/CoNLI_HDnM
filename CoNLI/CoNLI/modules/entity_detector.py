# base class for all entity detectors

from dataclasses import dataclass
import time
import logging
import json
import asyncio
from typing import List
from azure.core.credentials import AzureKeyCredential
from azure.ai.textanalytics.aio import TextAnalyticsClient

from CoNLI.modules.arguments import TAArguments

# entity class for hallucination detection
@dataclass
class HdEntity:
    hypothesis: str # E2E hypothesis generated by entity detector feeding to HD
    span_text : str # the text of the entity in the original text
    entity_type : str
    entity_name : str # the name of the entity in standard format
    span_start : int = -1 # [spanStart, spanEnd) character index of the entity in the original text
    span_end : int = -1
    detection_type: str = 'NA'

    def __hash__(self) -> int:
        return hash(self.hypothesis)

class EntityDetectorBase:
    def __init__(self) -> None:
        pass

    # detect entities in a given text, return a list of entities
    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return [[] for _ in range(len(text_content))] # return empty list by default

class PassThroughEntityDetector(EntityDetectorBase):
    def __init__(self) -> None:
        super().__init__()

    # detect entities in a given text, return a list of entities
    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        # simply treat the whole sentennce as a giant "entity",
        # so that hallucination detection can be applied to the whole sentence

        # TODO: change the entity type "whole_sentence" to a constant and defined in a central place
        return [[HdEntity(s, s, "whole_sentence", s, 0, len(s), 'PASS_THROUGH')] for s in text_content]

class EnsembledEntityDetector(EntityDetectorBase) :
    def __init__(self, detectors : List[EntityDetectorBase]) -> None:
        super().__init__()
        self.detectors = detectors
        assert self._check_detectors(), "PassThroughEntityDetector is not the last detector"

    def _detect_entities(self, text_content : str) -> List[HdEntity]:
        results = []

        for detector in self.detectors:
            if type(detector) is PassThroughEntityDetector and len(results) != 0:
                continue
            cur_result = detector.detect_entities(text_content)
            results.extend(cur_result)
        return results
    
    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return [self._detect_entities(text) for text in text_content]

    def _detect_bkg_entities(self, text_content : str) -> List[HdEntity]:
        for detector in self.detectors:
            if type(detector) is BkgEntityDetector:
                return detector.detect_entities(text_content)
        return []
    
    def detect_bkg_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return [self._detect_bkg_entities(text) for text in text_content]

    def _check_detectors(self) -> bool:
        if len(self.detectors) == 1:
            return True

        for detector in self.detectors[:-1]:
            if type(detector) is PassThroughEntityDetector:
                return False
        return True


class GenTAEntityDetector(EntityDetectorBase) :
    def __init__(self, ta_args : TAArguments) -> None:
        super().__init__()
        self.ta_args = ta_args
        api_key = ta_args.api_key
        if not api_key:
            raise ValueError("API_KEY is not defined in the config file and LANGUAGE_KEY is not set in environment")

        self.credential = AzureKeyCredential(api_key)
        self.endpoint = ta_args.endpoint

        # default to allow all entity types
        self.default_allowed_entity_types = [
            "Quantity_Number",
            "Event",
            "Location",
            "DateTime_DateRange",
            "Person",
            "PersonType",
            "Skill",
            "Quantity_Currency",
            "DateTime_Duration"
          ]

    # append category + subcategory
    @staticmethod
    def get_general_entity_category(entity):
        if entity.subcategory:
            return "{0}_{1}".format(entity.category, entity.subcategory)
        else:
            return "{0}".format(
                entity.category)

    async def _detect_entities(self, text_contents: List[str]) -> List[List[HdEntity]]:
        ta_client = TextAnalyticsClient(
            endpoint=self.endpoint,
            credential=self.credential
        )
        async with ta_client:
            while True:
                try:
                    result = await ta_client.recognize_entities(
                        documents=text_contents)
                    # aggresively not allowing any error in TA.
                    ta_results = []
                    for r in result:
                        assert (not r.is_error), r.error
                        ta_results.append(r)

                    break
                except Exception as e:
                    errStr = str(e).lower()

                    if "invalid subscription key or wrong api endpoint" in errStr:
                        raise Exception(
                            f'[TA] Unexpected, unrecoverable error: {errStr}')
                    else:
                        logging.info(
                            f"[TA] Unexpected error, retryable error: {errStr}")
                        time.sleep(5)
                        continue
        entity_types_allow_list = self.get_entity_types_allow_list()
        return_list = []
        for result, text_content_str in zip(ta_results, text_contents):
            def to_hd_entity(text, entity):
                name_norm = None
                eType = GenTAEntityDetector.get_general_entity_category(entity)
                name_org = entity.text
                start_pos = entity.offset
                end_pos = entity.offset + len(entity.text)
                hypothesis = f'{text[0:entity.offset]}[ {entity.text} ]{text[end_pos:]}'
                hd_entity = HdEntity(hypothesis, name_org, eType, name_norm, start_pos, end_pos, f'TA-{eType}')
                return hd_entity

            if len(entity_types_allow_list) > 0:
                return_val = [to_hd_entity(
                    text_content_str, r) for r in result.entities if GenTAEntityDetector.get_general_entity_category(r) in entity_types_allow_list]
            else:
                return_val = [to_hd_entity(text_content_str, r) for r in result.entities]
            return_list.append(return_val)

        return return_list

    def detect_entities(self, text_content : List[str]) -> List[List[HdEntity]]:
        return asyncio.run(self._detect_entities(text_content))

    # dup code - TODO: refactor
    def get_entity_types_allow_list(self) -> List[str]:
        if self.ta_args.entities is None:
            return self.default_allowed_entity_types # return default list
        else:
            return self.ta_args.entities


class EntityDetectorFactory:
    @staticmethod
    def create_entity_detector(entity_detector_type : str, **kwargs) -> EntityDetectorBase:
        type_with_info = entity_detector_type.split(':')
        entity_detector_type_real = type_with_info[0]
        if entity_detector_type_real == "ensemble":
            # ensembled, arguments provided as: ensemble:detector1,detector2,detector3
            detect_type_list = type_with_info[1].split(',')
            return EntityDetectorFactory.create_ensembled_entity_detector(detect_type_list, **kwargs)
        else:
            return EntityDetectorFactory.create_single_entity_detector(entity_detector_type_real, **kwargs)

    @staticmethod
    def create_single_entity_detector(entity_detector_type : str, **kwargs) -> EntityDetectorBase:
        if entity_detector_type == "pass_through":
            return PassThroughEntityDetector()
        elif entity_detector_type == "ta-general":
            ta_args = kwargs['ta_args']
            return GenTAEntityDetector(ta_args)
        elif entity_detector_type == "base":
            return EntityDetectorBase() # only used for testing ensembled entity detector
        else:
            raise ValueError("Unknown entity detector type: {entity_detector_type}")

    @staticmethod
    def create_ensembled_entity_detector(detectors_to_ensemble : List[str], **kwargs) -> EntityDetectorBase:
        if detectors_to_ensemble is None or len(detectors_to_ensemble) == 0:
            raise ValueError("Ensembled entity detector must have at least one detector")

        detectors = []
        for detector_type in detectors_to_ensemble:
            detectors.append(EntityDetectorFactory.create_single_entity_detector(detector_type, **kwargs))

        return EnsembledEntityDetector(detectors)
